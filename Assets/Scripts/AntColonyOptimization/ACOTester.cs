using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using Astar.MyScript;
using TMPro;

public class ACOTester : MonoBehaviour
{
    // The ACO Controller.
    private ACOCON MyACOCON = new ACOCON();
    // Array of possible waypoints.
    private List<GameObject> Waypoints = new List<GameObject>();
    [SerializeField] private float Q = 0.0006f;
    [SerializeField] private float alpha = 1.0f;
    [SerializeField] private float beta = 0.0001f;
    [SerializeField] private int antCount = 50;

    [SerializeField] private float currSpeed = 12f;
    [SerializeField] private int logs = 10;
    private int increaseCount;


    // multiple goal points
    public List<GameObject> CollectionPoints = new List<GameObject>();
    // Connections between nodes.
    private List<ACOConnection> Connections = new List<ACOConnection>();
    // The route generated by the ACO algorithm.
    private List<ACOConnection> MyACORoute = new List<ACOConnection>();
    // Debug line offset.
    private Vector3 OffSet = new Vector3(0, 0.5f, 0);
    // The Start node for any created route.
    [SerializeField] private GameObject StartNode;
    // The max length of a path created by the ACO.
    [SerializeField] private int MaxPathLength;
    private int currentGoalIndex = 0;
    private bool isAgentMoving = true;

    public TextMeshProUGUI storeDistance;
    public TextMeshProUGUI storeTime;
    public TextMeshProUGUI storeSpeed;
    public TextMeshProUGUI storeItems;
    private float newDist;
    private float newTime;
    private float newSpeed;

    private MyScript myScript;

    // Start is called before the first frame update
    void Start()
    {
        myScript = GetComponent<MyScript>();
        if (StartNode == null)
        {
            Debug.Log("No start waypoint node.");
            return;
        }

        myScript.notification(gameObject.name + " is moving", "success");

        VisGraphWaypointManager tmpWpM = StartNode.GetComponent<VisGraphWaypointManager>();

        if (tmpWpM == null)
        {
            Debug.Log("Start node is not a waypoint.");
            return;
        }

        GameObject[] GameObjectsWithWaypointTag;
        GameObjectsWithWaypointTag = GameObject.FindGameObjectsWithTag("Waypoint");

        foreach (GameObject waypoint in GameObjectsWithWaypointTag)
        {
            VisGraphWaypointManager tmpWaypointCon = waypoint.GetComponent<VisGraphWaypointManager>();

            if (tmpWaypointCon)
            {
                if (tmpWaypointCon.WaypointType == VisGraphWaypointManager.waypointPropsList.Goal)
                {
                    Waypoints.Add(waypoint);
                }
            }
        }

        // Add all goal points to the Waypoints list.
        Waypoints.AddRange(CollectionPoints);
        
        foreach (GameObject waypoint in Waypoints)
        {
            VisGraphWaypointManager tmpWaypointCon = waypoint.GetComponent<VisGraphWaypointManager>();

            foreach (VisGraphConnection aVisGraphConnection in tmpWaypointCon.Connections)
            {
                ACOConnection aConnection = new ACOConnection();
                aConnection.SetConnection(waypoint, aVisGraphConnection.ToNode, MyACOCON.DefaultPheromone);
                Connections.Add(aConnection);
            }
        }


        if (Connections.Count <= 1)
        {
            Debug.Log("Warning, you have set 1 or 0 goal nodes. You need at least 2. However, more is expected.");
            return;
        }

        // Set ACO parameters
        MyACOCON.Q = Q;
        MyACOCON.Alpha = alpha;
        MyACOCON.Beta = beta;

        MyACORoute = MyACOCON.ACO(antCount, 25, Waypoints.ToArray(), Connections, StartNode, MaxPathLength);

        if (MyACORoute.Count == 0)
        {
            Debug.Log("Warning, ACO did not return a path. Please check all logs.");
        }
    }
    // Draws debug objects in the editor and during editor play (if option set).
    void OnDrawGizmos()
    {
        if (MyACORoute.Count > 0)
        {
            foreach (ACOConnection aConnection in MyACORoute)
            {
                Gizmos.color = Color.white;
                Gizmos.DrawLine((aConnection.FromNode.transform.position + OffSet),
                    (aConnection.ToNode.transform.position + OffSet));
            }
        }
    }
    
    public float CurrSpeed {
        get { return currSpeed; }
        set { currSpeed = value; }
    }

    void Update() {
        if (isAgentMoving) {
            if (MyACORoute.Count > 0 && currentGoalIndex < MyACORoute.Count) {
                ACOConnection currentConnection = MyACORoute[currentGoalIndex];
                Vector3 newTargetPosition = new Vector3(currentConnection.ToNode.transform.position.x, transform.position.y, currentConnection.ToNode.transform.position.z);
                
                if (transform.position.x != newTargetPosition.x && transform.position.z != newTargetPosition.z) {
                    transform.position = Vector3.MoveTowards(transform.position, newTargetPosition, currSpeed * Time.deltaTime);
                    Vector3 direction = newTargetPosition - transform.position;
                    Quaternion lookRotation = Quaternion.LookRotation(direction);
                    transform.rotation = Quaternion.RotateTowards(transform.rotation, lookRotation, 200 * Time.deltaTime);
                }

                float distanceToGoal = Vector3.Distance(transform.position, newTargetPosition);

                if (distanceToGoal < 0.1f) {
                    currentGoalIndex++;

                    if (currentGoalIndex < MyACORoute.Count) {
                        Debug.Log("Agent reached waypoint: " + currentConnection.ToNode.name);
                    }
                }
            }

            float calcDist = currSpeed * Time.smoothDeltaTime;
            newDist = newDist + calcDist;
            newTime = newTime + Time.smoothDeltaTime;

            myScript.RotateWheel(currSpeed);

            storeDistance.text = newDist.ToString("F2");
            storeTime.text = newTime.ToString("F2");

            if (newTime >= 1) {
                newSpeed = newDist / newTime;
                storeSpeed.text = currSpeed.ToString("F2");
            }
        }
        
    }

    void OnTriggerEnter(Collider collider) {
        if (collider != null && collider.CompareTag(gameObject.name + "Log")) {
            Destroy(collider.gameObject);
            increaseCount++;
            myScript.notification(gameObject.name + " has collected "+ increaseCount + " logs", "info");
            storeItems.text = increaseCount.ToString();
            float calcSpeedPercentage = logs * 0.1f;
            newSpeed = newDist / newTime;
            float conversionSpeed = newSpeed * (1 - calcSpeedPercentage);
            currSpeed = conversionSpeed;
            storeSpeed.text = currSpeed.ToString("F2");

            if (increaseCount >= logs) {
                isAgentMoving = false;
                enabled = false;

                PathfindingTester pathfindingTester = GetComponent<PathfindingTester>();
                if (pathfindingTester != null) {
                    pathfindingTester.enabled = true;

                    pathfindingTester.SetStartNode(CollectionPoints[CollectionPoints.Count - 1]);
                    pathfindingTester.SetEndNode(StartNode);
                    pathfindingTester.CurrSpeed = conversionSpeed;
                    pathfindingTester.accumulatedDistance = newDist;
                    pathfindingTester.accumulatedTime = newTime;
                }
            }
        }
    }

    public void GetNotification(string text, string type) {
        if (text == "" && type == "") {
            myScript.notification(gameObject.name + " has collected "+ logs + " logs", "info");
            return;
        }
        myScript.notification(text, type);
        return;
    }
}